{"id":"repomap-core-0os","title":"Phase 3: Workflow documentation consolidation","description":"Consolidate all workflow documentation to reflect specialized orchestrator modes (§3 Phase 3).\n\n## Deliverables\n\n1. Verify all orchestrate-*.md files are annotated as reference docs (from Phase 1 + Phase 2 work)\n2. Update capabilities.md registry:\n   - Add process-orchestrator and audit-orchestrator to Orchestrator Workflows section\n   - Add whenToUse guidance for each\n   - Update activation patterns\n3. Update tasks.md with new invocation patterns:\n   - Replace /orchestrate-start-task + /orchestrate-execute-task references with process-orchestrator invocation\n   - Replace /orchestrate-pressure-test reference with audit-orchestrator invocation\n4. Add deprecation markers on generic-Orchestrator-based workflow invocations\n\n## Files Affected\n\n- .kilocode/rules/memory-bank/capabilities.md\n- .kilocode/rules/memory-bank/tasks.md\n- All .kilocode/workflows/orchestrate-*.md files (verify annotations)\n\n## Acceptance Criteria\n\n- capabilities.md accurately reflects new mode landscape\n- tasks.md shows current invocation patterns\n- No stale references to old /orchestrate-* workflow invocations without deprecation markers\n- Operator can unambiguously determine which orchestrator to use from capabilities.md\n\n## References\n\n- Plan: plans/specialized-orchestrator-modes.md §3 Phase 3, §7\n- Depends on: repomap-core-2b9 (Phase 1 doc downgrade), repomap-core-qvz (Phase 2 doc annotation)","status":"closed","priority":2,"issue_type":"chore","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-14T14:44:17.654782999-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-15T17:06:53.541273694-05:00","closed_at":"2026-02-15T17:06:53.541273694-05:00","close_reason":"Closed","labels":["consolidation","documentation","phase-3"],"dependencies":[{"issue_id":"repomap-core-0os","depends_on_id":"repomap-core-2b9","type":"blocks","created_at":"2026-02-14T14:44:17.657150286-05:00","created_by":"galeavenworth-personal"},{"issue_id":"repomap-core-0os","depends_on_id":"repomap-core-qvz","type":"blocks","created_at":"2026-02-14T14:44:17.659580942-05:00","created_by":"galeavenworth-personal"},{"issue_id":"repomap-core-0os","depends_on_id":"repomap-core-1nb","type":"parent-child","created_at":"2026-02-15T11:20:40.973115768-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-1jj","title":"Phase C: Create /factory-health-check workflow","description":"Create the orchestrated /factory-health-check workflow combining Layers 1-3 of observability (§10 Phase C).\n\n## Workflow Steps\n\n1. Run receipt_audit.py for recent bead IDs (Layer 1 — deterministic)\n2. Spawn Factory Inspector subtask with audit reports as input (Layer 2 — interpretive)\n3. Inspector analyzes patterns and produces health report (Layer 2)\n4. Present compiled health report and recommendations (Layer 3)\n\n## Trigger Options\n\n- Manual: /factory-health-check (operator-initiated)\n- Post-workflow: Run as final step of /orchestrate-execute-task (self-audit)\n- Periodic: After every N completed tasks\n\n## Parent Orchestrator\n\nCan be invoked by Process Orchestrator (if Phase 1 complete) or generic Orchestrator.\n\n## Deliverables\n\n1. Workflow document: .kilocode/workflows/factory-health-check.md\n2. Integration instructions for orchestrators\n3. Example invocation and expected output format\n\n## Acceptance Criteria\n\n- Workflow produces a health report from real workflow receipts\n- Combines deterministic audit (receipt_audit.py) with interpretive analysis (Factory Inspector)\n- Report includes actionable recommendations\n\n## References\n\n- Plan: plans/specialized-orchestrator-modes.md §10, Phase C\n- Depends on: repomap-core-9o8 (Factory Inspector mode), repomap-core-9uq (Process Orchestrator — soft dep)","status":"open","priority":3,"issue_type":"feature","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-14T14:45:04.509168046-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-14T14:45:04.509168046-05:00","labels":["observability","phase-c","workflow"],"dependencies":[{"issue_id":"repomap-core-1jj","depends_on_id":"repomap-core-9o8","type":"blocks","created_at":"2026-02-14T14:45:04.511721053-05:00","created_by":"galeavenworth-personal"},{"issue_id":"repomap-core-1jj","depends_on_id":"repomap-core-9uq","type":"blocks","created_at":"2026-02-14T14:45:04.51410805-05:00","created_by":"galeavenworth-personal"},{"issue_id":"repomap-core-1jj","depends_on_id":"repomap-core-3wn","type":"parent-child","created_at":"2026-02-15T11:20:41.119904152-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-1nb","title":"Specialized orchestrator modes — replace document-driven orchestration with purpose-built modes","description":"Replace the current generic orchestrator + workflow markdown architecture with specialized orchestrator modes (process-orchestrator, audit-orchestrator) that have built-in tool routing, lifecycle management, and handoff packet contracts. This is the critical path fix for systematic line faults caused by subtasks failing to use required tools.","status":"closed","priority":1,"issue_type":"epic","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-15T11:20:33.220959104-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-15T17:07:03.667466708-05:00","closed_at":"2026-02-15T17:07:03.667466708-05:00","close_reason":"Closed"}
{"id":"repomap-core-1tg","title":"Orchestration research — token economics, interaction patterns, and workflow-as-code","description":"Cross-cutting research tasks that inform specialized orchestrator design: token budget analysis, mode interaction heuristics (switch_mode vs new_task), Fitter contract verification, and long-horizon workflow-as-code feasibility.","status":"open","priority":2,"issue_type":"epic","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-15T11:20:33.500080517-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-15T11:20:33.500080517-05:00"}
{"id":"repomap-core-2b9","title":"Phase 1: Downgrade orchestrate-start/execute-task.md to reference documentation","description":"Convert the orchestrate-start-task.md and orchestrate-execute-task.md workflow files from runtime templates to reference documentation (§3 Phase 1 deliverable 4).\n\n## Changes Required\n\nFor each file:\n1. Add header notice: 'This document is reference documentation. The Process Orchestrator mode embeds this logic natively.'\n2. Mark sections that are now handled by the Process Orchestrator roleDefinition\n3. Keep the documents as reference for understanding the logic, but they are no longer read at runtime by the orchestrator\n\n## Files Affected\n\n- .kilocode/workflows/orchestrate-start-task.md (527 lines)\n- .kilocode/workflows/orchestrate-execute-task.md (876 lines)\n\n## Acceptance Criteria\n\n- Both files have reference-doc header annotation\n- Process Orchestrator mode does NOT load these files\n- Documents remain accurate as reference material\n\n## References\n\n- Plan: plans/specialized-orchestrator-modes.md §3 Phase 1\n- Depends on: repomap-core-9uq (mode must exist before downgrading docs)","status":"closed","priority":2,"issue_type":"chore","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-14T14:43:46.222129926-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-15T15:41:21.807961471-05:00","closed_at":"2026-02-15T15:41:21.807961471-05:00","close_reason":"Closed","labels":["documentation","phase-1"],"dependencies":[{"issue_id":"repomap-core-2b9","depends_on_id":"repomap-core-9uq","type":"blocks","created_at":"2026-02-14T14:43:46.224237093-05:00","created_by":"galeavenworth-personal"},{"issue_id":"repomap-core-2b9","depends_on_id":"repomap-core-1nb","type":"parent-child","created_at":"2026-02-15T11:20:40.965626393-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-35t","title":"Phase 3 — Artifact Query API","description":"Port the deterministic, typed artifact query API into repomap-core so agents can query .repomap/ artifacts programmatically. This includes ArtifactStore (normalized collections), QueryEngine (typed filter AST), QueryService facade, and optional CLI subcommand.\n\nReferences:\n- Implementation guide: plans/repomap-core-query-bundle/IMPLEMENTATION_GUIDE.md (authoritative)\n- Roadmap: plans/ROADMAP.md (Phase 3)\n- Staging source: plans/repomap-core-query-bundle/staging/\n\nDefinition of Done:\n- All 5 child tasks completed and closed\n- src/query/ package exists with ArtifactStore, QueryEngine, QueryService\n- Agents can execute structured queries against .repomap/ artifacts\n- All quality gates pass (ruff format, ruff check, mypy, pytest)\n","status":"open","priority":1,"issue_type":"epic","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:32:58.729936337-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-11T21:46:55.98578068-05:00","dependencies":[{"issue_id":"repomap-core-35t","depends_on_id":"repomap-core-ywk","type":"blocks","created_at":"2026-02-11T21:36:05.538734701-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-35t.1","title":"Port ArtifactStore into src/query/","description":"Copy and adapt the ArtifactStore from the staging query bundle into repomap-core. Provides normalized collection access to .repomap/ artifacts with receipts (matched locations). Replace hard-coded filenames with contract constants.\n\nKey methods: get_collection(), get_record_location(), list_collections(), artifacts_hash\n\nReferences:\n- Source to port: plans/repomap-core-query-bundle/staging/repomap_claims/artifact_store.py\n- Legacy reference: plans/repomap-core-query-bundle/legacy/repomap_claims/artifact_store.py\n- Contract constants: src/contract/artifacts.py (TIER1_ARTIFACT_SPECS)\n- Guide: plans/repomap-core-query-bundle/IMPLEMENTATION_GUIDE.md (Step 1)\n\nDefinition of Done:\n- src/query/artifact_store.py exists\n- ArtifactStore loads all Tier-1 artifacts as normalized collections\n- Uses contract constants for artifact filenames\n- get_collection(), get_record_location(), list_collections() work\n- artifacts_hash produces deterministic hash\n- No imports from repomap_claims\n- Quality gates pass\n","status":"open","priority":1,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:34:19.124405083-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-11T21:47:01.684661248-05:00","dependencies":[{"issue_id":"repomap-core-35t.1","depends_on_id":"repomap-core-35t","type":"parent-child","created_at":"2026-02-11T21:34:19.125829956-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-35t.2","title":"Port QueryEngine + StructuredQuery","description":"Copy and adapt the typed filter AST and query executor from the staging query bundle. Includes Pydantic models: FieldFilter, AndFilter, OrFilter, ExistsAssertion, CountAssertion, StructuredQuery, QueryResult.\n\nReferences:\n- Source to port: plans/repomap-core-query-bundle/staging/repomap_claims/query_engine.py\n- Legacy reference: plans/repomap-core-query-bundle/legacy/repomap_claims/query_engine.py\n- Guide: plans/repomap-core-query-bundle/IMPLEMENTATION_GUIDE.md (Step 2)\n\nDefinition of Done:\n- src/query/query_engine.py exists\n- All Pydantic models ported: FieldFilter, AndFilter, OrFilter, ExistsAssertion, CountAssertion, StructuredQuery, QueryResult\n- QueryEngine.execute() processes queries against ArtifactStore collections\n- Query validation (valid/invalid queries handled gracefully)\n- No imports from repomap_claims\n- Quality gates pass\n","status":"open","priority":1,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:34:22.644706085-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-11T21:47:06.874981421-05:00","dependencies":[{"issue_id":"repomap-core-35t.2","depends_on_id":"repomap-core-35t","type":"parent-child","created_at":"2026-02-11T21:34:22.645867059-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-35t.3","title":"Add QueryService facade","description":"Create a thin agent-friendly wrapper that combines ArtifactStore and QueryEngine into a simple API. Supports dict-based query input (auto-parsed via model_validate), plus convenience methods exists() and count().\n\nReferences:\n- Guide: plans/repomap-core-query-bundle/IMPLEMENTATION_GUIDE.md (Step 3)\n\nDefinition of Done:\n- src/query/service.py exists with QueryService class\n- QueryService.__init__(artifacts_dir) sets up store + engine\n- execute(query) accepts StructuredQuery or dict, returns QueryResult\n- exists(collection, filter_dict) returns bool\n- count(collection, filter_dict) returns int\n- src/query/__init__.py re-exports public API\n- Quality gates pass\n","status":"open","priority":1,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:34:31.406299323-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-11T21:47:12.06498424-05:00","dependencies":[{"issue_id":"repomap-core-35t.3","depends_on_id":"repomap-core-35t","type":"parent-child","created_at":"2026-02-11T21:34:31.407562677-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-35t.4","title":"Query API tests — round-trip, edge cases, determinism","description":"Test the query API with round-trip queries on fixture artifacts, edge cases (missing artifacts, invalid queries), and determinism verification.\n\nReferences:\n- Guide: plans/repomap-core-query-bundle/IMPLEMENTATION_GUIDE.md (Suggested Tests)\n\nDefinition of Done:\n- Test fixtures with valid .repomap/ artifacts\n- Round-trip test: build query → execute → verify matches + receipts\n- Edge case: missing artifacts return empty collections, don't crash\n- Edge case: invalid queries return query_valid=False or raise validation error\n- Determinism: same query + artifacts → same results\n- Quality gates pass\n","status":"open","priority":1,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:34:35.152896982-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-11T21:47:16.522228795-05:00","dependencies":[{"issue_id":"repomap-core-35t.4","depends_on_id":"repomap-core-35t","type":"parent-child","created_at":"2026-02-11T21:34:35.154239705-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-35t.5","title":"(Optional) CLI query subcommand","description":"Add 'repomap query' subcommand to the CLI. Minimal interface: reads a query from a JSON file and returns matches + matched_locations as JSON output.\n\nUsage: repomap query --artifacts-dir .repomap --query-file query.json\n\nReferences:\n- Guide: plans/repomap-core-query-bundle/IMPLEMENTATION_GUIDE.md (Step 4)\n- Source: src/cli.py (_build_parser)\n\nDefinition of Done:\n- CLI accepts 'query' subcommand\n- Reads query from --query-file (JSON)\n- Returns JSON output with matches + matched_locations\n- Error handling for missing files, invalid JSON, invalid queries\n- Quality gates pass\n","status":"open","priority":2,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:34:39.403258652-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-11T21:47:21.185104105-05:00","dependencies":[{"issue_id":"repomap-core-35t.5","depends_on_id":"repomap-core-35t","type":"parent-child","created_at":"2026-02-11T21:34:39.404463946-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-3k9","title":"Phase 4 — Change Slice Foundation","description":"Implement the deterministic foundation for change slices — graph-derived contracts that define the structural boundary of a planned code change. This is repomap-core's contribution to Layer 4 of the whitepaper architecture.\n\nReferences:\n- Roadmap: plans/ROADMAP.md (Phase 4)\n- Whitepaper: plans/proposed_architecture_whitepaper.md (Layer 4: Change Slices as Contracts)\n- Architecture review: plans/whitepaper_architecture_review.md (Layer 4 gap analysis)\n\nDefinition of Done:\n- All 5 child tasks completed and closed\n- N-hop neighborhood extraction works on dependency + call graphs\n- Slice artifact format specified and generated\n- Contract extended with slice artifact specs\n- All quality gates pass\n","status":"open","priority":1,"issue_type":"epic","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:33:01.957494006-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-11T21:47:26.074049208-05:00","dependencies":[{"issue_id":"repomap-core-3k9","depends_on_id":"repomap-core-ywk","type":"blocks","created_at":"2026-02-11T21:36:10.278811368-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-3k9.1","title":"N-hop neighborhood extraction from dependency + call graphs","description":"Given a symbol or module, extract the inbound/outbound neighborhood to depth N from deps.edgelist and calls.jsonl. This is the core graph algorithm that powers change slices.\n\nShould support both module-level (from deps.edgelist) and symbol-level (from calls.jsonl) extraction.\n\nReferences:\n- Whitepaper: plans/proposed_architecture_whitepaper.md (Layer 4)\n- Architecture review: plans/whitepaper_architecture_review.md (Change Slices section)\n- Existing graph code: src/graph/algos.py (build_dependency_graph, find_cycles)\n\nDefinition of Done:\n- Function extracts N-hop inbound callers from a given symbol/module\n- Function extracts N-hop outbound callees from a given symbol/module\n- Works with both deps.edgelist (module-level) and calls.jsonl (symbol-level)\n- Returns structured graph neighborhood (nodes + edges)\n- Deterministic output for given inputs\n- Quality gates pass\n","status":"open","priority":1,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:34:43.281508629-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-11T21:47:31.499512593-05:00","dependencies":[{"issue_id":"repomap-core-3k9.1","depends_on_id":"repomap-core-3k9","type":"parent-child","created_at":"2026-02-11T21:34:43.282689983-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-3k9.2","title":"Slice artifact format specification","description":"Design and specify the slice artifact format. A slice defines: the target symbol, inbound callers within N hops, outbound callees within N hops, dependency neighborhood, and resolution tier coverage metrics for the region.\n\nReferences:\n- Whitepaper: plans/proposed_architecture_whitepaper.md (Layer 4)\n- Architecture review: plans/whitepaper_architecture_review.md (Layer 4)\n- Pattern: src/contract/artifacts.py (Tier1ArtifactSpec for format)\n\nDefinition of Done:\n- Pydantic model for SliceRecord defined\n- Format supports: target symbol, inbound/outbound neighborhoods, edge metadata\n- Resolution coverage metrics per node (resolution tier distribution)\n- Schema version included\n- Format documented\n- Quality gates pass\n","status":"open","priority":1,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:34:47.197583821-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-11T21:47:36.675127827-05:00","dependencies":[{"issue_id":"repomap-core-3k9.2","depends_on_id":"repomap-core-3k9","type":"parent-child","created_at":"2026-02-11T21:34:47.198752355-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-3k9.3","title":"Slice generation from graph data","description":"Implement the generator that produces change slice artifacts from the dependency graph and call graph data. Combines N-hop extraction with artifact formatting.\n\nReferences:\n- Depends on: repomap-core-3k9.1 (N-hop extraction) and repomap-core-3k9.2 (format spec)\n- Pattern: src/artifacts/generators/ (existing generator pattern)\n\nDefinition of Done:\n- SliceGenerator produces slice artifacts given a target symbol and depth N\n- Consumes deps.edgelist and calls.jsonl as inputs\n- Output is deterministic\n- Integrates with generate_all_artifacts() or standalone invocation\n- Quality gates pass\n","status":"open","priority":1,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:34:50.623460482-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-11T21:47:41.904240829-05:00","dependencies":[{"issue_id":"repomap-core-3k9.3","depends_on_id":"repomap-core-3k9","type":"parent-child","created_at":"2026-02-11T21:34:50.659827054-05:00","created_by":"galeavenworth-personal"},{"issue_id":"repomap-core-3k9.3","depends_on_id":"repomap-core-3k9.1","type":"blocks","created_at":"2026-02-11T21:48:32.970296911-05:00","created_by":"galeavenworth-personal"},{"issue_id":"repomap-core-3k9.3","depends_on_id":"repomap-core-3k9.2","type":"blocks","created_at":"2026-02-11T21:48:37.298773751-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-3k9.4","title":"Contract extension for slice artifacts","description":"Extend the contract surface to include slice artifact specs. Add validation rules for slice schema.\n\nReferences:\n- Source: src/contract/artifacts.py\n- Source: src/contract/validation.py\n- Source: src/contract/models.py\n\nDefinition of Done:\n- Slice artifact constants added to contract\n- SliceRecord model exposed via contract surface\n- Validation rules for slice artifact format\n- Quality gates pass\n","status":"open","priority":1,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:34:54.55982568-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-11T21:47:47.848514031-05:00","dependencies":[{"issue_id":"repomap-core-3k9.4","depends_on_id":"repomap-core-3k9","type":"parent-child","created_at":"2026-02-11T21:34:54.560960024-05:00","created_by":"galeavenworth-personal"},{"issue_id":"repomap-core-3k9.4","depends_on_id":"repomap-core-3k9.2","type":"blocks","created_at":"2026-02-11T21:48:41.054138677-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-3k9.5","title":"Post-change recomputation support (diff detection)","description":"Support re-running artifact generation after code changes and detecting structural drift. Enable comparison of before/after slices to flag unintended structural changes.\n\nReferences:\n- Whitepaper: plans/proposed_architecture_whitepaper.md (Layer 4 — 'Post-change graph recomputation must not introduce unintended structural drift')\n- Source: src/verify/verify.py (verify_determinism — existing diff pattern)\n\nDefinition of Done:\n- Artifacts can be regenerated and diffed against previous versions\n- Structural drift detection: new/removed edges, changed resolution tiers\n- Report format for drift summary\n- Quality gates pass\n","status":"open","priority":2,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:34:58.780945822-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-11T21:47:52.449823305-05:00","dependencies":[{"issue_id":"repomap-core-3k9.5","depends_on_id":"repomap-core-3k9","type":"parent-child","created_at":"2026-02-11T21:34:58.782316115-05:00","created_by":"galeavenworth-personal"},{"issue_id":"repomap-core-3k9.5","depends_on_id":"repomap-core-3k9.3","type":"blocks","created_at":"2026-02-11T21:48:45.421346755-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-3wn","title":"Factory observability — deterministic receipt auditing and workflow health inspection","description":"Add deterministic introspection to the factory-line architecture: receipt manifests, audit tooling, factory-inspector mode, health-check workflows, and self-audit integration. Enables proactive detection of line faults like tool-skipping before they cascade.","status":"open","priority":2,"issue_type":"epic","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-15T11:20:33.361690814-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-15T11:20:33.361690814-05:00"}
{"id":"repomap-core-3wo","title":"Orchestrator composability patterns — handoff contracts and return parsing","description":"PIVOTED from 'Workflow-as-code feasibility — MCP workflow engine' on 2026-02-15.\n\nNative new_task composability (proven in nested-new-task-experiment-2026-02-15) supersedes the MCP workflow engine concept. The orchestrator's message parameter is the program, the todos parameter is the structured input, and attempt_completion is the return value.\n\n## Revised Scope\n\n1. Define handoff packet schemas for orchestrator→orchestrator delegation\n2. Define return format conventions (parseable markdown with known headers, or fenced JSON blocks)\n3. Document nesting depth budget policies (recommended max 3 levels)\n4. Establish error/failure propagation patterns across nesting levels\n5. Document the validated mode interaction heuristic (new_task vs switch_mode)\n\n## Evidence\n\n- Experiment: docs/research/nested-new-task-experiment-2026-02-15.md\n- Analysis: docs/research/orchestrator-composability-analysis-2026-02-15.md\n\n## Acceptance Criteria\n\n- Handoff packet schema documented and tested in at least one composability scenario\n- Return format convention documented with parsing examples\n- Nesting depth budget policy documented with cost rationale\n- Mode interaction heuristic table validated against experiment findings","status":"closed","priority":3,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-14T14:42:51.72454813-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-16T14:06:15.995695445-05:00","closed_at":"2026-02-16T14:06:15.995695445-05:00","close_reason":"Closed","labels":["deferred","exploratory","research"],"dependencies":[{"issue_id":"repomap-core-3wo","depends_on_id":"repomap-core-1tg","type":"parent-child","created_at":"2026-02-15T11:20:41.272767059-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-4f0","title":"Plant Manager — strategic orchestrator for workflow system ownership","description":"Strategic orchestrator role that owns the fabrication plant itself: mode definitions, skills, contracts, fit profiles, gate configurations, and the orchestration patterns connecting them.\n\n## Motivation\n\nThe nested new_task experiment (2026-02-15) proved orchestrator composability works with strong context isolation and model routing. This enables a three-tier architecture:\n\n| Tier | Role | Scope |\n|------|------|-------|\n| Strategic | Plant Manager (this epic) | Workflow system, mode/skill evolution, health oversight |\n| Tactical | process-orchestrator, audit-orchestrator | Development lifecycle, adversarial QA |\n| Specialist | code, architect, fitter, factory-inspector, etc. | Bounded deliverables |\n\n## Key Principles\n\n1. **Plant Manager's codebase is .kilocode/, .kilocodemodes, AGENTS.md** — not src/\n2. **Sequential execution is fine** — matches fabrication model, prevents merge conflicts\n3. **Max nesting depth: 3** — plant-manager → tactical-orch → specialist\n4. **Start lean** — v0 is mode definition + one composability pattern tested\n5. **Fitter integration absorbed** — from closed repomap-core-c6j (Fitter contract verification)\n\n## Architecture\n\n```\nHuman invokes plant-manager\n  → spawns factory-inspector to assess health (optional)\n  → receives structured health report\n  → spawns process-orchestrator to implement workflow fix\n    → process-orchestrator spawns code/architect/fitter as needed\n  → plant-manager validates via workflow-specific gates\n```\n\n## References\n\n- Experiment: docs/research/nested-new-task-experiment-2026-02-15.md\n- Analysis: docs/research/orchestrator-composability-analysis-2026-02-15.md\n- Absorbed: repomap-core-c6j (Fitter integration verification)\n- Related: repomap-core-1tg (orchestration research), repomap-core-3wn (factory observability)","status":"open","priority":2,"issue_type":"epic","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-15T19:07:05.287376998-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-15T19:07:05.287376998-05:00"}
{"id":"repomap-core-4f0.1","title":"Plant Manager mode definition in .kilocodemodes","description":"Define the plant-manager mode in .kilocodemodes.\n\n## Mode Specification\n\n- Slug: plant-manager\n- Model: anthropic/claude-opus-4.6 (strategic reasoning)\n- Tool groups: read, edit, command, mcp (all MCP servers)\n- File regex: covers .kilocode/, .kilocodemodes, AGENTS.md, docs/research/\n\n## roleDefinition Scope\n\nStrategic orchestrator for the fabrication plant:\n- Owns workflow system artifacts (modes, skills, contracts, fit profiles, gate configs)\n- Spawns tactical orchestrators (process-orchestrator, audit-orchestrator) via new_task\n- Spawns factory-inspector for health assessment\n- Dispatches fitter for workflow-system repairs\n- Validates changes via workflow-specific gates\n- Does NOT directly edit src/ code — delegates to process-orchestrator\n\n## customInstructions\n\n- Three-tier composability pattern (strategic → tactical → specialist)\n- Max nesting depth: 3 levels\n- Handoff packet format for tactical orchestrator delegation\n- Workflow-specific gate checklist (mode validation, skill loading, contract parsing)\n- Fitter dispatch patterns (absorbed from repomap-core-c6j)\n\n## Acceptance Criteria\n\n- Mode definition validates in .kilocodemodes (YAML syntax correct)\n- Mode can be selected and invoked\n- roleDefinition clearly scopes plant ownership vs product development\n- customInstructions include composability patterns\n\n## References\n\n- Analysis: docs/research/orchestrator-composability-analysis-2026-02-15.md","status":"open","priority":2,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-15T19:07:17.251894742-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-15T19:07:17.251894742-05:00","dependencies":[{"issue_id":"repomap-core-4f0.1","depends_on_id":"repomap-core-4f0","type":"parent-child","created_at":"2026-02-15T19:07:17.253095477-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-4f0.2","title":"Workflow-specific gate definitions for plant-manager","description":"Define quality gates specific to workflow system changes (as opposed to src/ code gates).\n\n## Gates to Define\n\n1. **Mode validation** — .kilocodemodes parses as valid YAML, all mode slugs are unique, required fields present\n2. **Skill loading** — All SKILL.md files referenced in skills/ are syntactically valid, location paths resolve\n3. **Contract parsing** — All contract .md files in .kilocode/contracts/ parse correctly\n4. **Workflow coherence** — Mode definitions reference valid tool groups, file regex patterns compile\n\n## Implementation\n\n- Script or Python tool under .kilocode/tools/ (e.g., workflow_gate.py or workflow_gate.sh)\n- Can be invoked by plant-manager as part of its gate phase\n- Should produce structured pass/fail output parseable by orchestrators\n\n## Acceptance Criteria\n\n- Gate script exists and is executable\n- Covers mode validation, skill loading, contract parsing\n- Pass/fail output is deterministic and parseable\n- Integrates with bounded_gate.py runner (or equivalent for workflow gates)\n\n## References\n\n- Analysis: docs/research/orchestrator-composability-analysis-2026-02-15.md","status":"open","priority":2,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-15T19:07:28.382550911-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-15T19:07:28.382550911-05:00","dependencies":[{"issue_id":"repomap-core-4f0.2","depends_on_id":"repomap-core-4f0","type":"parent-child","created_at":"2026-02-15T19:07:28.383670417-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-4f0.3","title":"Composability handoff contracts — plant-manager ↔ tactical orchestrators","description":"Define the handoff packet schemas and return format conventions for plant-manager delegating to tactical orchestrators.\n\n## Deliverables\n\n### 1. Handoff Packet Schema (Plant Manager → Tactical Orchestrator)\n\nThe message parameter passed to new_task when plant-manager spawns a tactical orchestrator. Must include:\n- task_id (bead reference)\n- scope description (what to do)\n- file pointers (what to touch)\n- success criteria (how to verify)\n- constraints (what NOT to do)\n- return format requirements (how to report back)\n\n### 2. Return Format Convention (Tactical Orchestrator → Plant Manager)\n\nThe attempt_completion result format. Options:\n- Markdown with known headers (## Status, ## Changes Made, ## Evidence, ## Issues Found)\n- Fenced JSON block with structured fields\n- Hybrid: markdown narrative + fenced JSON summary\n\n### 3. Error/Failure Propagation\n\nHow tactical orchestrators report failures back to plant-manager:\n- Gate failures (which gate, what error, was fitter attempted?)\n- Scope violations (task was larger than estimated)\n- Blocked dependencies (needs input plant-manager didn't provide)\n\n## Acceptance Criteria\n\n- Handoff packet schema documented with example\n- Return format convention documented with parsing guidance\n- Error propagation patterns documented\n- At least one end-to-end composability test (plant-manager → process-orchestrator → specialist)\n\n## References\n\n- Experiment: docs/research/nested-new-task-experiment-2026-02-15.md (return value findings)\n- Related: repomap-core-3wo (composability patterns research)","status":"open","priority":2,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-15T19:07:42.08417332-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-15T19:07:42.08417332-05:00","dependencies":[{"issue_id":"repomap-core-4f0.3","depends_on_id":"repomap-core-4f0","type":"parent-child","created_at":"2026-02-15T19:07:42.085341966-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-4f0.4","title":"Factory-inspector integration as spawnable subtask","description":"Integrate factory-inspector mode as a subtask spawnable by plant-manager for health assessment.\n\n## Scope\n\nDefine and test the pattern where plant-manager spawns factory-inspector via new_task to get a structured health report before making strategic decisions.\n\n## Deliverables\n\n1. Message template for plant-manager → factory-inspector delegation\n2. Return format for inspector health reports (parseable by plant-manager)\n3. Integration test: plant-manager spawns inspector, receives report, acts on it\n\n## Dependencies\n\n- repomap-core-4f0.1 (Plant Manager mode definition)\n- repomap-core-9o8 (Factory Inspector mode — can be minimal/stubbed)\n\n## Acceptance Criteria\n\n- Plant-manager can spawn factory-inspector subtask\n- Inspector returns structured health report\n- Plant-manager can parse and act on the report\n\n## References\n\n- Analysis: docs/research/orchestrator-composability-analysis-2026-02-15.md","status":"open","priority":2,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-15T19:07:50.821837393-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-15T19:07:50.821837393-05:00","dependencies":[{"issue_id":"repomap-core-4f0.4","depends_on_id":"repomap-core-4f0","type":"parent-child","created_at":"2026-02-15T19:07:50.823231955-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-4f0.5","title":"Fitter dispatch patterns from plant-manager context","description":"Define how plant-manager dispatches fitter for workflow-system repairs (absorbed from repomap-core-c6j).\n\n## Scope\n\nThe fitter currently handles line-health repairs for code gates (ruff, mypy, pytest). Plant-manager needs to dispatch fitter for workflow-system-specific repairs:\n- Mode definition syntax errors\n- Skill loading failures\n- Contract parsing failures\n- Gate configuration drift\n\n## Deliverables\n\n1. Fitter dispatch contract for workflow-system faults (Line Fault Contract variant)\n2. Restoration Contract for workflow-system repairs\n3. Verified that fitter contracted payloads work when parent is plant-manager (custom mode)\n4. Updated fitter mode definition if needed to handle workflow artifacts\n\n## Absorbed From\n\nrepomap-core-c6j question 2: 'Verify that contracted payloads (Line Fault → Restoration) work identically when parent is a custom mode vs built-in Orchestrator.'\n\n## Acceptance Criteria\n\n- Fitter can receive and process workflow-system fault payloads\n- Restoration contracts work for workflow artifacts\n- End-to-end: plant-manager detects workflow gate failure → dispatches fitter → fitter restores\n\n## References\n\n- Closed: repomap-core-c6j (Fitter integration verification)\n- Current contracts: .kilocode/contracts/line_health/","status":"open","priority":2,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-15T19:08:03.026038242-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-15T19:08:03.026038242-05:00","dependencies":[{"issue_id":"repomap-core-4f0.5","depends_on_id":"repomap-core-4f0","type":"parent-child","created_at":"2026-02-15T19:08:03.027206577-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-4g0","title":"Research: Custom mode new_task capabilities","description":"CRITICAL GATE — blocks entire specialized orchestrator plan.\n\nInvestigate whether Kilo Code custom modes can access the new_task tool for spawning subtasks. This combines research areas §5a and §5b from the plan.\n\n## Questions to Answer\n\n1. Does Kilo Code's tool group system allow granting new_task to custom modes?\n2. Is new_task in a specific tool group (orchestrator?) or universally available?\n3. When a custom mode spawns a subtask via new_task, does the subtask get the same context isolation (summary-only returns) as the built-in Orchestrator?\n4. Does full context leak back to the parent (defeating token savings)?\n\n## Research Approach\n\n- Read Kilo Code source/docs for tool group definitions\n- Check new_task tool availability in custom mode configurations\n- Measure token usage in parent context after subtask completion\n\n## References\n\n- Kilo Code Custom Modes docs: https://kilo.ai/docs/agent-behavior/custom-modes\n- Kilo Code new_task tool docs: https://kilo.ai/docs/features/tools/new-task\n- Plan: plans/specialized-orchestrator-modes.md §5a, §5b\n\n## Acceptance Criteria\n\n- Document whether new_task is available to custom modes (yes/no)\n- Document context isolation behavior for custom-mode-spawned subtasks\n- If NO: document what failed and pivot plan to Approach B (enhanced generic Orchestrator)","status":"closed","priority":1,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-14T14:42:14.8159436-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-15T12:09:51.740827684-05:00","closed_at":"2026-02-15T12:09:51.740827684-05:00","close_reason":"Closed","labels":["gate","phase-0","research"],"dependencies":[{"issue_id":"repomap-core-4g0","depends_on_id":"repomap-core-1nb","type":"parent-child","created_at":"2026-02-15T11:20:40.949524719-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-82w","title":"Research: Receipt infrastructure design — persistence format and thinking session introspection","description":"Design the receipt persistence format and validate thinking session introspection capabilities (§10a + §10b).\n\n## Questions\n\n### Receipt Persistence Format (§10a)\nShould receipts beyond gate_runs.jsonl be persisted in a structured format, or is filesystem glob matching sufficient?\n\nOptions:\n- A: Keep current approach (JSONL for gates, filesystem for sessions)\n- B: Unified receipt log (workflow_receipts.jsonl) recording all receipt types\n- C: Hybrid — gate runs stay in JSONL, add receipt_manifest_actual.json per bead_id\n\n### Thinking Session Introspection (§10b)\nCan receipt_audit.py meaningfully inspect thinking session JSON files without the sequential thinking MCP server?\n\nSession exports are JSON files. If the schema is documented, a script can parse them deterministically. If opaque, agent interpretation is required.\n\n## Research Approach\n\n1. Examine exported session file format (.kilocode/thinking/*.json) to determine schema\n2. Identify which quality metrics are extractable deterministically (stage count, thought count, branch budget)\n3. Evaluate persistence options against complexity and query needs\n4. Produce recommendation for Phase A implementation\n\n## Acceptance Criteria\n\n- Decision on receipt persistence format with rationale\n- Documented thinking session JSON schema (or assessment of opacity)\n- List of deterministically-extractable thinking quality metrics\n\n## References\n\n- Plan: plans/specialized-orchestrator-modes.md §10a, §10b\n- Receipt inventory table: §10 of plan","status":"closed","priority":2,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-14T14:43:05.759658734-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-15T18:42:14.598746081-05:00","closed_at":"2026-02-15T18:42:14.598746081-05:00","close_reason":"Closed","labels":["observability","research"],"dependencies":[{"issue_id":"repomap-core-82w","depends_on_id":"repomap-core-3wn","type":"parent-child","created_at":"2026-02-15T11:20:41.108630489-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-87i","title":"Phase 1 — Foundation Hardening","description":"Harden the existing repomap-core foundation before adding new features. Fix inconsistencies, expand test coverage, and align documentation.\n\nReferences:\n- Roadmap: plans/ROADMAP.md (Phase 1)\n- Architecture: plans/whitepaper_architecture_review.md\n\nDefinition of Done:\n- All 7 child tasks completed and closed\n- All quality gates pass (ruff format, ruff check, mypy, pytest)\n- No known inconsistencies in existing artifact generation\n","status":"closed","priority":1,"issue_type":"epic","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:32:51.154221223-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-14T00:20:06.704693934-05:00","closed_at":"2026-02-14T00:20:06.704693934-05:00","close_reason":"Closed"}
{"id":"repomap-core-87i.1","title":"Fix nested_gitignore consistency across all generators","description":"The nested_gitignore config option is supported in scanning (find_python_files) and passed through by DepsGenerator, but SymbolsGenerator and IntegrationsGenerator do not pass it. All generators must consistently honor this config.\n\nReferences:\n- Source: src/scan/files.py (find_python_files)\n- Source: src/artifacts/generators/symbols.py (SymbolsGenerator.generate)\n- Source: src/artifacts/generators/integrations.py (IntegrationsGenerator.generate)\n- Source: src/artifacts/generators/deps.py (DepsGenerator.generate — reference impl)\n- Config: src/rules/config.py (RepoMapConfig)\n\nDefinition of Done:\n- SymbolsGenerator.generate() passes nested_gitignore to find_python_files()\n- IntegrationsGenerator.generate() passes nested_gitignore to find_python_files()\n- Test verifies all generators produce identical file lists given same config\n- Quality gates pass\n","status":"closed","priority":1,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:33:13.652515876-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-11T22:22:31.556200039-05:00","closed_at":"2026-02-11T22:22:31.556200039-05:00","close_reason":"Closed","dependencies":[{"issue_id":"repomap-core-87i.1","depends_on_id":"repomap-core-87i","type":"parent-child","created_at":"2026-02-11T21:33:13.653949699-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-87i.2","title":"Module naming normalization — path-based to package-based","description":"Module names in artifacts use path-based naming (e.g., src.cli) instead of Python package names (e.g., repomap_core.cli). This causes ambiguity in dependency outputs and will block correct module identity in modules.jsonl. Normalize path_to_module() to produce package-resolvable names.\n\nReferences:\n- Source: src/utils.py (path_to_module)\n- Design: plans/deterministic_xref_callgraph_design.md (modules.jsonl section)\n- Artifacts: .repomap/deps.edgelist (shows src.* prefix issue)\n\nDefinition of Done:\n- path_to_module() produces package-resolvable module names\n- deps.edgelist uses normalized module names\n- symbols.jsonl qualified_name uses normalized module names\n- Existing tests updated for new naming\n- Quality gates pass\n","status":"closed","priority":1,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:33:17.327952595-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-12T19:36:18.746508187-05:00","closed_at":"2026-02-12T19:36:18.746508187-05:00","close_reason":"Closed","dependencies":[{"issue_id":"repomap-core-87i.2","depends_on_id":"repomap-core-87i","type":"parent-child","created_at":"2026-02-11T21:33:17.329174608-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-87i.3","title":"Test coverage expansion — artifact content tests","description":"No tests verify the actual content of generated artifacts. Add tests that generate artifacts from fixture repos and verify symbol records, dependency edges, and integration records contain expected content.\n\nReferences:\n- Generators: src/artifacts/generators/ (deps.py, symbols.py, integrations.py)\n- Orchestration: src/artifacts/write.py (generate_all_artifacts)\n\nDefinition of Done:\n- Test fixture repo exists under tests/fixtures/\n- Test verifies symbols.jsonl contains expected symbol records\n- Test verifies deps.edgelist contains expected edges\n- Test verifies deps_summary.json has correct statistics\n- Test verifies integrations_static.jsonl detects known integrations\n- Quality gates pass\n","status":"closed","priority":2,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:33:20.736970354-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-13T21:25:13.757671844-05:00","closed_at":"2026-02-13T21:25:13.757671844-05:00","close_reason":"Closed","dependencies":[{"issue_id":"repomap-core-87i.3","depends_on_id":"repomap-core-87i","type":"parent-child","created_at":"2026-02-11T21:33:20.738381957-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-87i.4","title":"Test coverage expansion — contract validation fixture tests","description":"Contract validation (validate_artifacts) is tested only for missing-dir error cases. Add fixture-based tests that validate well-formed and malformed artifacts to verify schema checking, JSONL line validation, and edgelist format validation.\n\nReferences:\n- Source: src/contract/validation.py (validate_artifacts, _validate_jsonl, _validate_deps_summary, _validate_edgelist)\n- Contract: src/contract/artifacts.py (TIER1_ARTIFACT_SPECS)\n\nDefinition of Done:\n- Test fixtures include valid Tier-1 artifacts that pass validation\n- Test fixtures include malformed artifacts that trigger specific validation errors\n- Tests cover JSONL schema validation, deps_summary schema, edgelist format\n- Quality gates pass\n","status":"closed","priority":2,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:33:24.545683941-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-13T19:18:33.389550317-05:00","closed_at":"2026-02-13T19:18:33.389550317-05:00","close_reason":"Closed","dependencies":[{"issue_id":"repomap-core-87i.4","depends_on_id":"repomap-core-87i","type":"parent-child","created_at":"2026-02-11T21:33:24.546929645-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-87i.5","title":"Test coverage expansion — layer classification tests","description":"Layer classification (classify_layer, is_violation) has no direct tests. Add tests that configure layer rules and verify correct classification and violation detection.\n\nReferences:\n- Source: src/rules/layers.py (classify_layer, is_violation)\n- Source: src/artifacts/summaries/builders.py (compute_layer_violations)\n- Config: src/rules/config.py (LayersConfig)\n\nDefinition of Done:\n- Tests configure layer rules matching repomap.toml structure\n- Tests verify classify_layer returns correct layer for known paths\n- Tests verify is_violation detects illegal cross-layer dependencies\n- Tests verify compute_layer_violations integrates correctly\n- Quality gates pass\n","status":"closed","priority":2,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:33:28.2844651-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-13T21:44:46.302338022-05:00","closed_at":"2026-02-13T21:44:46.302338022-05:00","close_reason":"Closed","dependencies":[{"issue_id":"repomap-core-87i.5","depends_on_id":"repomap-core-87i","type":"parent-child","created_at":"2026-02-11T21:33:28.285761634-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-87i.6","title":"README and documentation alignment","description":"README has minor drift: references 'repo_map/' as default dir while actual default is '.repomap'. Align all documentation with actual behavior.\n\nReferences:\n- README.md\n- Source: src/rules/config.py (RepoMapConfig.output_dir default)\n\nDefinition of Done:\n- README accurately describes default output directory\n- All CLI examples in README work as documented\n- No contradictions between README and actual behavior\n- Quality gates pass\n","status":"closed","priority":3,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:33:32.051020358-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-13T22:29:32.946830146-05:00","closed_at":"2026-02-13T22:29:32.946830146-05:00","close_reason":"Closed","dependencies":[{"issue_id":"repomap-core-87i.6","depends_on_id":"repomap-core-87i","type":"parent-child","created_at":"2026-02-11T21:33:32.052225041-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-87i.7","title":"Unused config cleanup — semantic/analyzer toggles","description":"RepoMapConfig defines semantic (embedding provider/model) and analyzers (complexity/docstrings/security) settings with no implementation behind them. Either remove these or document them as reserved for future use.\n\nReferences:\n- Source: src/rules/config.py (SemanticConfig, AnalyzersConfig)\n- Roadmap: plans/ROADMAP.md (Phase 1)\n\nDefinition of Done:\n- Unused config sections either removed or clearly marked as reserved/future\n- No config options that silently do nothing\n- Quality gates pass\n","status":"closed","priority":3,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:33:39.096751996-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-13T23:34:12.570747078-05:00","closed_at":"2026-02-13T23:34:12.570747078-05:00","close_reason":"Closed","dependencies":[{"issue_id":"repomap-core-87i.7","depends_on_id":"repomap-core-87i","type":"parent-child","created_at":"2026-02-11T21:33:39.09789408-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-9hd","title":"Phase A: Define receipt manifests and build receipt_audit.py","description":"Build the deterministic receipt auditing layer (§10 Phase A).\n\n## Deliverables\n\n### 1. Receipt Manifest Definitions\n\nDefine JSON manifest schemas for each workflow type specifying what receipts MUST exist upon completion. Per §10:\n\n- gate_run receipts: gate_ids, expected status, source (gate_runs.jsonl), key fields\n- thinking_session receipts: file glob pattern, minimum stages, minimum thoughts\n- Per-workflow manifests for orchestrate-execute-task and orchestrate-start-task\n\n### 2. receipt_audit.py Script\n\nDeterministic script at .kilocode/tools/receipt_audit.py that:\n\n1. Takes --bead-id \u003cid\u003e and --workflow \u003ctype\u003e\n2. Loads the receipt manifest for that workflow type\n3. Checks each required receipt:\n   - Gate runs: queries gate_runs.jsonl for matching bead_id + status\n   - Thinking sessions: glob-matches .kilocode/thinking/ for expected files\n   - Optionally checks thinking session internals (stages present, thought count)\n4. Emits structured audit report (JSON):\n   - receipts_expected: count\n   - receipts_found: count\n   - receipts_missing: list\n   - receipts_degraded: list (found but low quality)\n   - overall_status: COMPLETE | PARTIAL | MISSING\n\nThis is a SCRIPT, not an agent. Deterministic output from deterministic inputs.\n\n## Acceptance Criteria\n\n- receipt_audit.py runs successfully against existing gate_runs.jsonl\n- Produces correct COMPLETE/PARTIAL/MISSING status\n- Handles missing files gracefully (no crashes)\n- JSON output is machine-parseable\n\n## References\n\n- Plan: plans/specialized-orchestrator-modes.md §10, Phase A\n- Receipt inventory table: §10\n- Depends on: repomap-core-82w (receipt infrastructure design research)","status":"open","priority":2,"issue_type":"feature","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-14T14:44:33.66331824-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-14T14:44:33.66331824-05:00","labels":["observability","phase-a","tooling"],"dependencies":[{"issue_id":"repomap-core-9hd","depends_on_id":"repomap-core-82w","type":"blocks","created_at":"2026-02-14T14:44:33.665547677-05:00","created_by":"galeavenworth-personal"},{"issue_id":"repomap-core-9hd","depends_on_id":"repomap-core-3wn","type":"parent-child","created_at":"2026-02-15T11:20:41.112513426-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-9o8","title":"Phase B: Create factory-inspector mode and analysis skill","description":"UPDATED 2026-02-15: Reconceived as dual-use mode under orchestrator composability.\n\nCreate the Factory Inspector mode for interpretive receipt analysis (§10 Phase B).\n\n## Dual-Use Design\n\nFactory Inspector operates in two contexts:\n\n### 1. Human-Invoked (Standalone)\nHuman directly invokes factory-inspector mode for ad-hoc analysis of workflow health, gate history, and thinking session quality. Produces a health report.\n\n### 2. Plant-Manager-Spawned (Subtask)\nPlant Manager spawns factory-inspector via new_task with a structured message containing:\n- Specific analysis scope (e.g., 'analyze gate_runs.jsonl for the last 7 days')\n- Output format requirements (parseable for orchestrator consumption)\n- Return via attempt_completion with structured recommendations\n\nBoth contexts use the same mode definition — the difference is in the message/context provided.\n\n## Deliverables\n\n### 1. Mode Definition in .kilocodemodes\n\nSlug: factory-inspector\nTool groups: read, command, mcp (sequential thinking for analysis)\nFile regex: \\.(md|txt|json|jsonl)$\n\nroleDefinition (~60 lines):\n- Factory observability analyst\n- Reads receipt audit reports, thinking session exports, gate run history\n- Detects patterns, surfaces anomalies, recommends workflow improvements\n- Does NOT modify code or workflow definitions — produces analysis reports only\n- When spawned as subtask, returns structured recommendations via attempt_completion\n\n### 2. Analysis Skill\n\nCreate .kilocode/skills/factory-inspection/SKILL.md defining:\n- When to invoke Factory Inspector (standalone and subtask contexts)\n- Input expectations (audit report JSON, gate_runs.jsonl, thinking sessions)\n- Output format (health report for standalone, structured recommendations for subtask)\n\n### Key Difference from Fitter\n\n- Fitter = REACTIVE (gate FAULT → diagnose → fix)\n- Factory Inspector = PROACTIVE (reads history → finds patterns → recommends)\n\n## Quality Metrics the Inspector Evaluates\n\n(unchanged from original)\n\n## Acceptance Criteria\n\n- Mode definition validates in .kilocodemodes\n- Skill document provides guidance for both invocation contexts\n- Inspector can read receipt_audit.py output and produce analysis\n- Return format is parseable by Plant Manager orchestrator\n\n## References\n\n- Plan: plans/specialized-orchestrator-modes.md §10, Phase B\n- Analysis: docs/research/orchestrator-composability-analysis-2026-02-15.md\n- Depends on: repomap-core-9hd (receipt_audit.py must exist)","status":"open","priority":2,"issue_type":"feature","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-14T14:44:52.215812959-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-15T19:06:49.709587901-05:00","labels":["mode","observability","phase-b"],"dependencies":[{"issue_id":"repomap-core-9o8","depends_on_id":"repomap-core-9hd","type":"blocks","created_at":"2026-02-14T14:44:52.218317866-05:00","created_by":"galeavenworth-personal"},{"issue_id":"repomap-core-9o8","depends_on_id":"repomap-core-3wn","type":"parent-child","created_at":"2026-02-15T11:20:41.116261894-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-9uq","title":"Phase 1: Create process-orchestrator mode definition","description":"Create the Process Orchestrator custom mode in .kilocodemodes (§3 Phase 1).\n\n## Deliverables\n\n1. New mode definition in .kilocodemodes for process-orchestrator slug\n2. Compact roleDefinition (~80 lines) embedding:\n   - Lifecycle phases: discover → explore → prepare → execute → gate → land\n   - Subtask routing table (which mode for which phase — see §4 routing table)\n   - Quality gate requirements (bounded_gate.py, audit proof)\n   - Fitter routing for line faults\n   - Handoff packet structure\n   - Bounded retry policy\n3. customInstructions (~30 lines) with:\n   - Beads integration protocol\n   - Session export/import pattern\n   - Runtime model reporting requirement\n\n## Routing Table (from §4)\n\n| Phase | Target Mode | Purpose |\n|---|---|---|\n| Discovery | architect | Fetch task details, strategic context |\n| Exploration | architect | Codebase context, map dependencies |\n| Preparation | architect | Sequential thinking, approach selection |\n| Implementation | code | Write code, make changes |\n| Testing | code | Add/update tests |\n| Quality Gates | code | Run bounded gates, fix failures |\n| Line Fault | fitter | Restore gate health |\n| Documentation | docs-specialist | Update docs if needed |\n\n## Size Constraints\n\n- roleDefinition: ≤100 lines (hard budget per risk register)\n- customInstructions: ≤50 lines (hard budget per risk register)\n\n## Acceptance Criteria\n\n- Process Orchestrator can complete a full start→execute→land cycle\n- Token usage for orchestration context is ≤30% of current workflow-doc-loading approach\n- Subtask isolation works identically to built-in Orchestrator\n- All quality gate, audit proof, and beads integration behaviors preserved\n\n## References\n\n- Plan: plans/specialized-orchestrator-modes.md §3 Phase 1, §4 routing tables\n- Depends on: repomap-core-r9v (Phase 0 spike must pass)","status":"closed","priority":1,"issue_type":"feature","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-14T14:43:35.177953024-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-15T13:44:46.833891756-05:00","closed_at":"2026-02-15T13:44:46.833891756-05:00","close_reason":"Closed","labels":["mode","orchestrator","phase-1"],"dependencies":[{"issue_id":"repomap-core-9uq","depends_on_id":"repomap-core-r9v","type":"blocks","created_at":"2026-02-14T14:43:35.18034138-05:00","created_by":"galeavenworth-personal"},{"issue_id":"repomap-core-9uq","depends_on_id":"repomap-core-1nb","type":"parent-child","created_at":"2026-02-15T11:20:40.957417342-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-c6j","title":"Research: Mode interaction patterns — switching vs spawning, Fitter integration","description":"Establish heuristics for when orchestrators should use switch_mode vs new_task, and verify Fitter integration contracts work with custom modes (§5e + §5f).\n\n## Questions\n\n### Mode Switching vs Subtask Spawning (§5e)\nWhen should a specialized orchestrator use switch_mode (hand off control) vs new_task (spawn isolated subtask)?\n\n- switch_mode preserves context but loses isolation\n- new_task provides isolation but loses shared state\n\nProposed heuristic:\n- Use new_task when subtask has a clear, bounded deliverable (implementation, test writing, gate running)\n- Use switch_mode when work requires continuous access to accumulated context (debugging complex issue)\n- Never switch_mode from one orchestrator to another orchestrator\n\n### Fitter Integration (§5f)\nHow does the Process Orchestrator's line-fault routing to Fitter change?\n\nCurrent model: Generic Orchestrator reads 'Line Health Routing' section of orchestrate-execute-task.md.\nProposed model: Process Orchestrator knows Fitter routing natively.\n\nVerify that contracted payloads (Line Fault → Restoration) work identically when parent is a custom mode vs built-in Orchestrator.\n\n## Acceptance Criteria\n\n- Documented heuristic for switch_mode vs new_task usage\n- Verified Fitter contracted payloads work from custom modes\n- Any edge cases or gotchas documented\n\n## References\n\n- Plan: plans/specialized-orchestrator-modes.md §5e, §5f\n- Current Fitter routing: .kilocode/workflows/orchestrate-execute-task.md line ~434","status":"closed","priority":2,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-14T14:42:40.056090912-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-15T19:05:48.97273555-05:00","closed_at":"2026-02-15T19:05:48.97273555-05:00","close_reason":"Closed","labels":["architecture","research"],"dependencies":[{"issue_id":"repomap-core-c6j","depends_on_id":"repomap-core-1tg","type":"parent-child","created_at":"2026-02-15T11:20:41.268812263-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-jxn","title":"Phase 5 — Polish \u0026 1.0","description":"Final polish for repomap-core 1.0 release. Full verification coverage, comprehensive documentation, dogfooding validation, performance benchmarking, and layer rule activation.\n\nReferences:\n- Roadmap: plans/ROADMAP.md (Phase 5)\n\nDefinition of Done:\n- All 6 child tasks completed and closed\n- repomap-core analyzes itself producing all artifacts correctly\n- Documentation complete and accurate\n- Performance acceptable on representative codebases\n- All quality gates pass\n","status":"open","priority":2,"issue_type":"epic","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:33:09.384218749-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-11T21:47:57.173893531-05:00","dependencies":[{"issue_id":"repomap-core-jxn","depends_on_id":"repomap-core-35t","type":"blocks","created_at":"2026-02-11T21:36:20.6481398-05:00","created_by":"galeavenworth-personal"},{"issue_id":"repomap-core-jxn","depends_on_id":"repomap-core-3k9","type":"blocks","created_at":"2026-02-11T21:36:26.689216661-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-jxn.1","title":"Full determinism verification covering all new artifacts","description":"Extend verify_determinism() to cover all artifacts including modules.jsonl, refs.jsonl, calls.jsonl, refs_summary.json, and any slice artifacts. Ensure byte-identical output across multiple runs.\n\nReferences:\n- Source: src/verify/verify.py (verify_determinism)\n- Tests: tests/test_verify_determinism.py\n\nDefinition of Done:\n- verify_determinism() checks all generated artifacts (not just Tier-1)\n- Tests verify byte-identical output for all artifact types\n- Any non-determinism sources identified and fixed\n- Quality gates pass\n","status":"open","priority":1,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:35:02.150261377-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-11T21:48:02.875367818-05:00","dependencies":[{"issue_id":"repomap-core-jxn.1","depends_on_id":"repomap-core-jxn","type":"parent-child","created_at":"2026-02-11T21:35:02.151426511-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-jxn.2","title":"Complete README + API reference documentation","description":"Rewrite README to cover all features including new artifacts, query API, and change slices. Add API reference documentation for the public contract surface.\n\nReferences:\n- README.md\n- Source: src/contract/ (public API surface)\n\nDefinition of Done:\n- README covers: installation, usage, all CLI subcommands, all artifacts\n- API reference for contract models, query API, validation API\n- Examples for common agent workflows\n- No inaccuracies or drift from actual behavior\n- Quality gates pass\n","status":"open","priority":2,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:35:05.730060222-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-11T21:48:08.584549324-05:00","dependencies":[{"issue_id":"repomap-core-jxn.2","depends_on_id":"repomap-core-jxn","type":"parent-child","created_at":"2026-02-11T21:35:05.731131687-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-jxn.3","title":"Artifact format reference documentation","description":"Create comprehensive documentation of every artifact format (.repomap/ file), including schema, field descriptions, and usage examples.\n\nReferences:\n- All artifact models in src/artifacts/models/\n- Contract specs in src/contract/artifacts.py\n- Design: plans/deterministic_xref_callgraph_design.md (schema drafts)\n\nDefinition of Done:\n- Documentation covers every artifact: symbols.jsonl, deps.edgelist, deps_summary.json, integrations_static.jsonl, modules.jsonl, refs.jsonl, calls.jsonl, refs_summary.json\n- Each artifact: schema version, field descriptions, example records, sort order\n- Published as plans/artifact_format_reference.md or similar\n- Quality gates pass\n","status":"open","priority":2,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:35:11.868564453-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-11T21:48:14.165853244-05:00","dependencies":[{"issue_id":"repomap-core-jxn.3","depends_on_id":"repomap-core-jxn","type":"parent-child","created_at":"2026-02-11T21:35:11.869783616-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-jxn.4","title":"Dogfooding — repomap-core analyzes itself with all artifacts","description":"Run repomap-core against its own codebase and verify all artifacts are correct and useful. Validate symbols, deps, call graph, and refs for the repomap-core source tree.\n\nReferences:\n- Existing: .repomap/ directory (current self-analysis)\n- Source: src/artifacts/write.py (generate_all_artifacts)\n\nDefinition of Done:\n- repomap generate . produces all artifacts including new ones\n- Artifacts are correct for the repomap-core codebase\n- No crashes, no missing data, no incorrect resolutions\n- Self-analysis used to validate graph completeness\n- Quality gates pass\n","status":"open","priority":1,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:35:19.981625421-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-11T21:48:19.27885297-05:00","dependencies":[{"issue_id":"repomap-core-jxn.4","depends_on_id":"repomap-core-jxn","type":"parent-child","created_at":"2026-02-11T21:35:19.982850065-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-jxn.5","title":"Performance benchmarking on larger codebases","description":"Benchmark repomap-core on representative larger Python codebases to identify performance bottlenecks and establish baseline metrics.\n\nReferences:\n- Roadmap: plans/ROADMAP.md (Phase 5)\n\nDefinition of Done:\n- Benchmarked on at least 2 codebases larger than repomap-core itself\n- Metrics collected: wall time, memory peak, artifact sizes\n- Performance bottlenecks identified\n- Acceptable performance for intended use cases (minutes, not hours)\n- Quality gates pass\n","status":"open","priority":2,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:35:23.953240296-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-11T21:48:24.189144943-05:00","dependencies":[{"issue_id":"repomap-core-jxn.5","depends_on_id":"repomap-core-jxn","type":"parent-child","created_at":"2026-02-11T21:35:23.9543343-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-jxn.6","title":"Layer rule activation — define and enforce layers","description":"Define and activate layer rules for the repomap-core project itself. Configure repomap.toml with layer definitions matching the actual architecture (foundation, verification, interface) and enforce them via compute_layer_violations().\n\nReferences:\n- Source: src/rules/layers.py (classify_layer, is_violation)\n- Source: src/rules/config.py (LayersConfig)\n- Config: repomap.toml\n- Architecture: .kilocode/rules/memory-bank/architecture.md\n\nDefinition of Done:\n- repomap.toml defines layers matching documented architecture\n- Layer rules enforce: foundation depends on nothing, verification on foundation only, interface on all\n- compute_layer_violations() detects real violations if present\n- deps_summary.json includes layer_violations data\n- Zero violations in current codebase (or violations fixed)\n- Quality gates pass\n","status":"open","priority":2,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:35:27.930456778-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-11T21:48:29.637658956-05:00","dependencies":[{"issue_id":"repomap-core-jxn.6","depends_on_id":"repomap-core-jxn","type":"parent-child","created_at":"2026-02-11T21:35:27.931584373-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-l5w","title":"Phase D: Post-workflow self-audit integration","description":"Add automatic self-audit as the final step of workflow execution (§10 Phase D).\n\n## Deliverables\n\n1. Add a 'self-audit' step at the end of /orchestrate-execute-task (or Process Orchestrator)\n2. Run receipt_audit.py automatically before landing the plane\n3. Flag PARTIAL/MISSING receipt status as warnings (not blockers, initially)\n\n## Design\n\nWhen a workflow reaches the 'land' phase:\n1. Extract current bead_id from session\n2. Run: receipt_audit.py --bead-id \u003cid\u003e --workflow orchestrate-execute-task\n3. If overall_status is COMPLETE: proceed with landing\n4. If PARTIAL or MISSING: emit warning in handoff packet, still land\n\nThis creates a feedback signal without blocking workflow completion. Over time, the warning threshold can be tightened.\n\n## Acceptance Criteria\n\n- Self-audit runs automatically at end of workflow execution\n- PARTIAL/MISSING results appear as warnings in completion output\n- Does not block or fail the workflow (advisory only, initially)\n- Works with both Process Orchestrator and generic Orchestrator workflows\n\n## References\n\n- Plan: plans/specialized-orchestrator-modes.md §10, Phase D\n- Depends on: repomap-core-9hd (receipt_audit.py), repomap-core-1jj (/factory-health-check workflow)","status":"open","priority":3,"issue_type":"feature","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-14T14:45:15.958237816-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-14T14:45:15.958237816-05:00","labels":["observability","optional","phase-d"],"dependencies":[{"issue_id":"repomap-core-l5w","depends_on_id":"repomap-core-9hd","type":"blocks","created_at":"2026-02-14T14:45:15.960499153-05:00","created_by":"galeavenworth-personal"},{"issue_id":"repomap-core-l5w","depends_on_id":"repomap-core-1jj","type":"blocks","created_at":"2026-02-14T14:45:15.96286111-05:00","created_by":"galeavenworth-personal"},{"issue_id":"repomap-core-l5w","depends_on_id":"repomap-core-3wn","type":"parent-child","created_at":"2026-02-15T11:20:41.12362609-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-msm","title":"Research: Inspector → Fitter → Orchestrator feedback loop","description":"SIMPLIFIED 2026-02-15: Under orchestrator composability, the feedback loop becomes straightforward orchestrator coordination.\n\n## Original Problem\n\nWhen Factory Inspector recommends a Fit Profile change, there was no mechanism for that recommendation to propagate to Fitter defaults or Orchestrator gate invocations.\n\n## Simplified Design (Post-Composability)\n\nWith new_task composability proven, the Plant Manager orchestrator handles this directly:\n\n1. Plant Manager spawns Factory Inspector subtask → receives structured recommendations\n2. Plant Manager evaluates recommendations (strategic decision)\n3. Plant Manager spawns Fitter subtask with amendment payload → Fitter applies changes\n4. Plant Manager validates result via workflow-specific gates\n\nNo complex propagation mechanism, storage format, or approval workflow needed. The orchestrator IS the coordination mechanism.\n\n## Remaining Research Questions\n\n1. What format should Inspector recommendations use in attempt_completion return? (Parseable markdown vs fenced JSON)\n2. Should amendments be auto-applied or require human approval? (Start with human approval)\n3. How does Plant Manager track which amendments have been applied? (Gate run history)\n\n## Acceptance Criteria\n\n- Inspector recommendation return format specified\n- Plant Manager → Inspector → Fitter coordination pattern documented\n- Decision on auto-apply vs human-in-the-loop with rationale\n\n## References\n\n- Analysis: docs/research/orchestrator-composability-analysis-2026-02-15.md\n- Depends on: repomap-core-9o8 (Factory Inspector mode must be designed)","status":"open","priority":3,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-14T14:45:27.873268078-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-15T19:06:29.176901499-05:00","labels":["feedback-loop","observability","research"],"dependencies":[{"issue_id":"repomap-core-msm","depends_on_id":"repomap-core-9o8","type":"blocks","created_at":"2026-02-14T14:45:27.875530765-05:00","created_by":"galeavenworth-personal"},{"issue_id":"repomap-core-msm","depends_on_id":"repomap-core-3wn","type":"parent-child","created_at":"2026-02-15T11:20:41.127343148-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-qvs","title":"Phase 2: Create audit-orchestrator mode definition","description":"Create the Audit Orchestrator custom mode for adversarial reasoning workflows (§3 Phase 2).\n\n## Deliverables\n\n1. New mode definition in .kilocodemodes for audit-orchestrator slug\n2. Compact roleDefinition embedding adversarial orchestration logic:\n   - Spawn Identity Attack subtask → Product Skeptic mode\n   - Spawn Friction Audit subtask → Product Skeptic mode\n   - Spawn Surface Minimization subtask → Product Skeptic mode\n   - Spawn Leverage Hunt subtask → Architect mode\n   - Spawn Synthesis subtask → Architect mode\n   - Compile and present ranked recommendations\n\n## Routing Table (from §4)\n\n| Phase | Target Mode | Purpose |\n|---|---|---|\n| Identity Attack | product-skeptic | Adversarial identity critique |\n| Friction Audit | product-skeptic | Agent-as-user friction analysis |\n| Surface Minimization | product-skeptic | Removal candidate analysis |\n| Leverage Hunt | architect | Structural leverage identification |\n| Synthesis | architect | Integrate findings, rank recommendations |\n\n## Key Design Requirement\n\nThe mode must know that adversarial reasoning requires multiple attack vectors and that synthesis must weight findings by leverage, not just severity.\n\n## Size Constraints\n\n- roleDefinition: ≤100 lines\n- customInstructions: ≤50 lines\n\n## Acceptance Criteria\n\n- Audit Orchestrator produces identical quality pressure test reports as current workflow approach\n- Sequential thinking session management works across subtasks\n- Adversarial role assignment (Product Skeptic vs Architect) handled natively\n\n## References\n\n- Plan: plans/specialized-orchestrator-modes.md §2b, §3 Phase 2, §4\n- Depends on: repomap-core-r9v (Phase 0 spike must pass)","status":"closed","priority":2,"issue_type":"feature","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-14T14:43:59.004230085-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-15T16:49:38.008906864-05:00","closed_at":"2026-02-15T16:49:38.008906864-05:00","close_reason":"Closed","labels":["mode","orchestrator","phase-2"],"dependencies":[{"issue_id":"repomap-core-qvs","depends_on_id":"repomap-core-r9v","type":"blocks","created_at":"2026-02-14T14:43:59.049705943-05:00","created_by":"galeavenworth-personal"},{"issue_id":"repomap-core-qvs","depends_on_id":"repomap-core-1nb","type":"parent-child","created_at":"2026-02-15T11:20:40.961504048-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-qvz","title":"Phase 2: Annotate orchestrate-pressure-test.md as reference documentation","description":"Convert orchestrate-pressure-test.md from runtime template to reference documentation (§3 Phase 2 deliverable 3).\n\n## Changes Required\n\n1. Add header: 'This document is reference documentation. The Audit Orchestrator mode embeds this logic natively.'\n2. Mark sections now handled by the Audit Orchestrator roleDefinition\n3. Retain as reference material for understanding adversarial workflow logic\n\n## Files Affected\n\n- .kilocode/workflows/orchestrate-pressure-test.md\n\n## Acceptance Criteria\n\n- File has reference-doc header annotation\n- Audit Orchestrator mode does NOT load this file at runtime\n- Document remains accurate as reference\n\n## References\n\n- Plan: plans/specialized-orchestrator-modes.md §3 Phase 2\n- Depends on: repomap-core-qvs (audit-orchestrator mode must exist first)","status":"closed","priority":2,"issue_type":"chore","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-14T14:44:05.995619196-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-15T16:30:34.63195474-05:00","closed_at":"2026-02-15T16:30:34.63195474-05:00","close_reason":"Closed","labels":["documentation","phase-2"],"dependencies":[{"issue_id":"repomap-core-qvz","depends_on_id":"repomap-core-qvs","type":"blocks","created_at":"2026-02-14T14:44:05.997997493-05:00","created_by":"galeavenworth-personal"},{"issue_id":"repomap-core-qvz","depends_on_id":"repomap-core-1nb","type":"parent-child","created_at":"2026-02-15T11:20:40.969327021-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-r9v","title":"Phase 0: Spike test — custom mode with new_task access","description":"GATE — must pass before Phase 1 or Phase 2 can begin.\n\nEmpirically validate that custom modes with new_task tool access work as documented (§3 Phase 0).\n\n## Spike Test Steps\n\n1. Create a minimal custom mode in .kilocodemodes with:\n   - Simple roleDefinition: 'You are a test orchestrator'\n   - Tool group that includes new_task access\n   - Simple customInstructions: 'Spawn a subtask to Architect mode'\n2. Invoke the custom mode\n3. Verify all of:\n   - Can it call new_task?\n   - Does the spawned subtask get proper context isolation?\n   - Does the parent receive only summaries (not full subtask context)?\n   - Does attempt_completion from the subtask return control to the parent?\n\n## If Spike FAILS\n\nThe entire plan pivots to Approach B (enhanced generic Orchestrator with compact workflow profiles). Document what failed and why.\n\n## If Spike SUCCEEDS\n\nProceed to Phase 1 (process-orchestrator) and Phase 2 (audit-orchestrator).\n\n## Deliverables\n\n- Minimal test mode definition (temporary, removed after validation)\n- Pass/fail report with evidence (screenshots, token measurements)\n- Go/no-go decision for Phase 1\n\n## References\n\n- Plan: plans/specialized-orchestrator-modes.md §3 Phase 0\n- Depends on: repomap-core-4g0 (custom mode new_task research)","notes":"Spike test performed manually by user after repomap-core-4g0 was completed by agent (pre-merge). User confirmed new_task capability works in custom modes via manual spike test. User confirmation supercedes contradicting conclusions made by agents during repomap-core-4g0 capability assessment.","status":"closed","priority":1,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-14T14:43:19.274048366-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-15T13:26:22.7861054-05:00","closed_at":"2026-02-15T13:26:22.7861054-05:00","close_reason":"Closed","labels":["gate","phase-0","spike"],"dependencies":[{"issue_id":"repomap-core-r9v","depends_on_id":"repomap-core-4g0","type":"blocks","created_at":"2026-02-14T14:43:19.276266503-05:00","created_by":"galeavenworth-personal"},{"issue_id":"repomap-core-r9v","depends_on_id":"repomap-core-1nb","type":"parent-child","created_at":"2026-02-15T11:20:40.953631415-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-wt5","title":"Research: Token budget analysis — specialized orchestrators and nesting cost profiles","description":"UPDATED 2026-02-15: Scope expanded to include nesting cost profiles from composability experiment.\n\n## Original Question\n\nWhat is the actual token cost of:\n- (A) Loading a 500-900 line workflow .md into generic Orchestrator context\n- (B) A specialized orchestrator with ~80-line roleDefinition + ~30-line customInstructions\n\n## Added Question (from composability experiment)\n\nWhat is the per-level cost of orchestrator nesting via new_task?\n\n### Preliminary Data (from nested-new-task-experiment-2026-02-15)\n- 3-level nesting test cost: ~$0.25 total\n- Estimated per-level system prompt overhead: ~$0.08\n- Each level receives full system prompt + rules + environment details from scratch\n\n## Research Approach (Updated)\n\n1. Measure actual token counts for current workflow .md files\n2. Estimate roleDefinition + customInstructions token counts\n3. Measure system prompt baseline cost per nesting level\n4. Model total cost for 2-level and 3-level nesting scenarios\n5. Calculate break-even: at what task frequency does nesting overhead pay for itself via context discipline?\n\n## Acceptance Criteria\n\n- Token count table comparing current vs proposed approach\n- Nesting cost profile table (1-level, 2-level, 3-level)\n- Decision: proceed if total overhead is manageable for typical task sizes\n\n## References\n\n- Plan: plans/specialized-orchestrator-modes.md §5c\n- Experiment: docs/research/nested-new-task-experiment-2026-02-15.md\n- Analysis: docs/research/orchestrator-composability-analysis-2026-02-15.md","status":"closed","priority":2,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-14T14:42:26.508914754-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-15T19:30:44.561602672-05:00","closed_at":"2026-02-15T19:30:44.561602672-05:00","close_reason":"Closed","labels":["measurement","research"],"dependencies":[{"issue_id":"repomap-core-wt5","depends_on_id":"repomap-core-1tg","type":"parent-child","created_at":"2026-02-15T11:20:41.26432694-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-ywk","title":"Phase 2 — XRef + Call-Graph Artifacts","description":"Implement the deterministic cross-reference index and resolved call graph — the major new feature that completes Layer 1 of the whitepaper architecture. Produces modules.jsonl, refs.jsonl, calls.jsonl, and refs_summary.json artifacts.\n\nReferences:\n- Design: plans/deterministic_xref_callgraph_design.md (authoritative)\n- Roadmap: plans/ROADMAP.md (Phase 2)\n- Whitepaper: plans/proposed_architecture_whitepaper.md (Layer 1)\n- Architecture review: plans/whitepaper_architecture_review.md (Layer 1 gap analysis)\n\nDefinition of Done:\n- All 9 child tasks completed and closed\n- New artifacts (modules.jsonl, refs.jsonl, calls.jsonl, refs_summary.json) generated deterministically\n- Contract surface extended with new artifact specs and validation\n- All quality gates pass\n- repomap-core can analyze itself producing all new artifacts\n","status":"open","priority":0,"issue_type":"epic","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:32:54.847909467-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-11T21:44:58.408299596-05:00","dependencies":[{"issue_id":"repomap-core-ywk","depends_on_id":"repomap-core-87i","type":"blocks","created_at":"2026-02-11T21:36:14.372484435-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-ywk.1","title":"Add symbol_id and symbol_key to symbol records","description":"Extend SymbolRecord with two stable identifier fields:\n- symbol_id: precise location handle (sym:{path}::{qualified_name}@L{line}:C{col})\n- symbol_key: longitudinal identity (symkey:{path}::{qualified_name}::{kind})\n\nThese enable deterministic joining between symbols.jsonl and refs.jsonl/calls.jsonl.\n\nReferences:\n- Design: plans/deterministic_xref_callgraph_design.md (symbol_id and symbol_key sections)\n- Source: src/parse/treesitter_symbols.py (extract_symbols_treesitter)\n- Source: src/artifacts/generators/symbols.py (SymbolsGenerator.generate)\n- Model: src/artifacts/models/artifacts/symbols.py (SymbolRecord)\n- Contract: src/contract/models.py\n\nDefinition of Done:\n- SymbolRecord model includes symbol_id and symbol_key fields\n- symbols.jsonl emits both fields for every record\n- symbol_id is unique across all records (validated)\n- symbol_key is stable across runs when code doesn't change\n- Contract model updated\n- Quality gates pass\n","status":"closed","priority":0,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:33:42.615268735-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-14T20:27:06.813527648-05:00","closed_at":"2026-02-14T20:27:06.813527648-05:00","close_reason":"Closed","dependencies":[{"issue_id":"repomap-core-ywk.1","depends_on_id":"repomap-core-ywk","type":"parent-child","created_at":"2026-02-11T21:33:42.616523249-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-ywk.2","title":"Emit modules.jsonl canonical module identity artifact","description":"Produce a new artifact .repomap/modules.jsonl that maps every Python file to its canonical module name. This is the single source of truth for module identity, consumed by refs.jsonl and calls.jsonl.\n\nRecords: { path, module, is_package, package_root }\n\nReferences:\n- Design: plans/deterministic_xref_callgraph_design.md (modules.jsonl section)\n- Source: src/utils.py (path_to_module — produces module names)\n- Source: src/scan/files.py (find_python_files — discovers files)\n\nDefinition of Done:\n- New ModulesGenerator produces .repomap/modules.jsonl\n- Every Python file in scan has exactly one record\n- Module names are package-resolvable (not path-based)\n- Artifact is deterministic (sorted, stable output)\n- Contract updated with MODULES_JSONL constant and spec\n- Quality gates pass\n","status":"closed","priority":0,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:33:46.213876142-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-14T20:27:06.948344768-05:00","closed_at":"2026-02-14T20:27:06.948344768-05:00","close_reason":"Closed","dependencies":[{"issue_id":"repomap-core-ywk.2","depends_on_id":"repomap-core-ywk","type":"parent-child","created_at":"2026-02-11T21:33:46.215193095-05:00","created_by":"galeavenworth-personal"},{"issue_id":"repomap-core-ywk.2","depends_on_id":"repomap-core-ywk.1","type":"blocks","created_at":"2026-02-11T21:35:32.914550589-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-ywk.3","title":"Tier 0: Raw call-site capture → calls_raw.jsonl","description":"Extract all call sites from Python source using Tree-sitter AST traversal. Emit calls_raw.jsonl with syntax-only information (no resolution). Each record includes src_span, callee_expr, enclosing_symbol_id, and evidence.strategy=syntax_only.\n\nThis is immediately valuable as \"structured grep\" for agents.\n\nReferences:\n- Design: plans/deterministic_xref_callgraph_design.md (Tier 0 section)\n- Source: src/parse/treesitter_symbols.py (Tree-sitter infrastructure to extend)\n\nDefinition of Done:\n- New call-site extractor using Tree-sitter\n- calls_raw.jsonl emitted with all call sites\n- Each record has stable ref_id, src_span, callee_expr, enclosing_symbol_id\n- callee_expr follows normalization rules from design doc\n- resolved_to is null for all Tier 0 records\n- Output is deterministic (sorted by canonical sort key)\n- Quality gates pass\n","status":"closed","priority":0,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:33:51.206643796-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-15T18:33:20.093613174-05:00","closed_at":"2026-02-15T18:33:20.093613174-05:00","close_reason":"Closed","dependencies":[{"issue_id":"repomap-core-ywk.3","depends_on_id":"repomap-core-ywk","type":"parent-child","created_at":"2026-02-11T21:33:51.20781398-05:00","created_by":"galeavenworth-personal"},{"issue_id":"repomap-core-ywk.3","depends_on_id":"repomap-core-ywk.2","type":"blocks","created_at":"2026-02-11T21:35:37.075349777-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-ywk.4","title":"Tier 1: Module-level name resolution → calls.jsonl + refs.jsonl","description":"Build per-module name tables from local defs, import bindings, and trivial aliases. Resolve call sites where the callee can be linked to a known symbol via imports. Emit calls.jsonl and refs.jsonl with resolution payloads.\n\nUses modules.jsonl to unify import names to internal file paths.\n\nReferences:\n- Design: plans/deterministic_xref_callgraph_design.md (Tier 1 section)\n- Source: src/parse/ast_imports.py (extract_imports — import parsing)\n- Source: src/utils.py (path_to_module — module naming)\n\nDefinition of Done:\n- Per-module name table built from defs + imports + aliases\n- calls.jsonl emitted with resolved_to for resolvable calls\n- refs.jsonl emitted with all reference kinds (call, read, write, annotation, etc.)\n- Resolution includes symbol_id, qualified_name, confidence, evidence.strategy\n- Internal vs external classification per design doc rules\n- Partial resolution (resolved_base_to + member) supported\n- Output deterministic, sorted by canonical sort key\n- Quality gates pass\n","status":"closed","priority":0,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:33:55.047339-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-15T18:33:24.18702525-05:00","closed_at":"2026-02-15T18:33:24.18702525-05:00","close_reason":"Closed","dependencies":[{"issue_id":"repomap-core-ywk.4","depends_on_id":"repomap-core-ywk","type":"parent-child","created_at":"2026-02-11T21:33:55.048583823-05:00","created_by":"galeavenworth-personal"},{"issue_id":"repomap-core-ywk.4","depends_on_id":"repomap-core-ywk.3","type":"blocks","created_at":"2026-02-11T21:35:40.774952286-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-ywk.5","title":"Contract extension — new artifact specs + validation invariants","description":"Extend the contract surface to include all new artifacts from Phase 2. Add artifact specs, validation rules, and cross-artifact invariants.\n\nReferences:\n- Design: plans/deterministic_xref_callgraph_design.md (validation section)\n- Source: src/contract/artifacts.py (TIER1_ARTIFACT_SPECS)\n- Source: src/contract/validation.py (validate_artifacts)\n- Source: src/contract/models.py\n\nDefinition of Done:\n- MODULES_JSONL, REFS_JSONL, CALLS_JSONL, REFS_SUMMARY_JSON constants added\n- Artifact specs added to TIER1_ARTIFACT_SPECS (or new tier)\n- Validation: symbol_id uniqueness in symbols.jsonl\n- Validation: resolved_to.symbol_id exists in symbols.jsonl (when internal)\n- Validation: module fields match modules.jsonl mapping\n- Validation: resolved_to.dst_module matches modules.jsonl\n- JSONL schema validation for new artifacts\n- Quality gates pass\n","status":"open","priority":1,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:33:58.497723104-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-11T21:44:59.0378997-05:00","dependencies":[{"issue_id":"repomap-core-ywk.5","depends_on_id":"repomap-core-ywk","type":"parent-child","created_at":"2026-02-11T21:33:58.498975467-05:00","created_by":"galeavenworth-personal"},{"issue_id":"repomap-core-ywk.5","depends_on_id":"repomap-core-ywk.4","type":"blocks","created_at":"2026-02-11T21:35:49.033944179-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-ywk.6","title":"Tier 2: Class-context resolution (self, cls, super)","description":"Resolve deterministic class-context call patterns:\n- ClassName.method() when ClassName resolves to known class\n- self.method() to enclosing class method (marked virtual/overridable)\n- cls.method() for classmethod contexts\n- super().method() to base class method when base is statically identifiable\n\nReferences:\n- Design: plans/deterministic_xref_callgraph_design.md (Tier 2 section)\n- Source: src/parse/treesitter_symbols.py (symbol catalog with class info)\n\nDefinition of Done:\n- self.method() resolved to enclosing class method symbol\n- cls.method() resolved similarly for classmethod contexts\n- super().method() resolved when single base class is statically known\n- ClassName.method() resolved when ClassName is in symbol catalog\n- All resolutions carry appropriate evidence.strategy and confidence\n- Virtual/overridable markers present where applicable\n- Quality gates pass\n","status":"open","priority":1,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:34:02.670471265-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-11T21:44:59.162828454-05:00","dependencies":[{"issue_id":"repomap-core-ywk.6","depends_on_id":"repomap-core-ywk","type":"parent-child","created_at":"2026-02-11T21:34:02.671667879-05:00","created_by":"galeavenworth-personal"},{"issue_id":"repomap-core-ywk.6","depends_on_id":"repomap-core-ywk.4","type":"blocks","created_at":"2026-02-11T21:35:45.563560975-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-ywk.7","title":"Summary artifact — refs_summary.json","description":"Emit .repomap/refs_summary.json with aggregate statistics about cross-references and call resolution. Agent-friendly for quick gating and inspection.\n\nReferences:\n- Design: plans/deterministic_xref_callgraph_design.md (refs_summary.json)\n- Pattern: src/artifacts/summaries/builders.py (existing summary pattern)\n\nDefinition of Done:\n- refs_summary.json emitted with: total refs, total calls, resolution rates by tier\n- Counts broken down by ref_kind\n- Internal vs external resolution counts\n- Average confidence scores\n- Deterministic output\n- Quality gates pass\n","status":"open","priority":2,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:34:07.182353911-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-11T21:44:59.289056012-05:00","dependencies":[{"issue_id":"repomap-core-ywk.7","depends_on_id":"repomap-core-ywk","type":"parent-child","created_at":"2026-02-11T21:34:07.183566805-05:00","created_by":"galeavenworth-personal"},{"issue_id":"repomap-core-ywk.7","depends_on_id":"repomap-core-ywk.4","type":"blocks","created_at":"2026-02-11T21:36:01.485297004-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-ywk.8","title":"Deterministic ref_id + expr normalization","description":"Ensure every ref/call record has a deterministic ref_id following the design doc format: ref:{path}@L{line}:C{col}:{ref_kind}:{expr}. Apply expr normalization rules consistently across refs.jsonl and calls.jsonl.\n\nReferences:\n- Design: plans/deterministic_xref_callgraph_design.md (ref_id and expr normalization sections)\n\nDefinition of Done:\n- ref_id emitted on every record in refs.jsonl and calls.jsonl\n- ref_id format matches design doc specification\n- expr normalization rules applied: whitespace stripped, dotted names preserved, dynamic placeholders used\n- callee_expr in calls.jsonl excludes argument text\n- No file-system-dependent prefixes in expr\n- Quality gates pass\n","status":"open","priority":1,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:34:11.375834906-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-11T21:44:59.416909711-05:00","dependencies":[{"issue_id":"repomap-core-ywk.8","depends_on_id":"repomap-core-ywk","type":"parent-child","created_at":"2026-02-11T21:34:11.37703832-05:00","created_by":"galeavenworth-personal"},{"issue_id":"repomap-core-ywk.8","depends_on_id":"repomap-core-ywk.3","type":"blocks","created_at":"2026-02-11T21:35:55.946595873-05:00","created_by":"galeavenworth-personal"}]}
{"id":"repomap-core-ywk.9","title":"(Optional) Tier 3: Lightweight type inference","description":"Optional tier: resolve obj.method() when obj type can be inferred from local annotations, direct construction assignments (obj = TypeName(...)), or simple factory returns within the same file. Strictly bounded — no imports executed, no runtime evaluation.\n\nReferences:\n- Design: plans/deterministic_xref_callgraph_design.md (Tier 3 section)\n\nDefinition of Done:\n- Type inference from local annotations resolves method calls\n- Type inference from direct construction resolves method calls\n- evidence.strategy distinguishes type_from_annotation vs type_from_construction\n- No cross-file inference\n- No runtime evaluation\n- Quality gates pass\n","status":"open","priority":3,"issue_type":"task","owner":"galeavenworth+personal@gmail.com","created_at":"2026-02-11T21:34:15.676482705-05:00","created_by":"galeavenworth-personal","updated_at":"2026-02-11T21:44:59.54498101-05:00","dependencies":[{"issue_id":"repomap-core-ywk.9","depends_on_id":"repomap-core-ywk","type":"parent-child","created_at":"2026-02-11T21:34:15.677633629-05:00","created_by":"galeavenworth-personal"}]}
